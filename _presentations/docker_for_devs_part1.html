---
layout: presentation
pres_title: Docker For Developers - Part 1
---

class: center, middle

# THIS PRESENTATION IS A WORK IN PROGRESS
# Docker for Developers
## Part 1

---

# Agenda
- Key Concepts
- What is Docker?
- What is a Container?
- Containers != VMs
- Containers ∪ VMs
- Running a Container
- Containers Alongside Your Code
- Building a Container
- Your Code in Containers

---

# Key Concepts

What you should probably know before this talk
- bash
    - minimally, enough to run commands and navigate the filesystem
- What a virtual machine is
- Some basic networking
- Some (very) basic network programming

What I hope this talk teaches you
- What Docker is
- What a container is
- How containers differ from VMs
    - conceptually, don't expect a libcontainer deep dive
- How to run a container
- How to use containers to help you write your code
- How to put your code in a container
- How to run your containerized code

???

If they have an interest in this talk, they probably know
enough to get by.

More knowledge of bash is handy for more complicated flags/args/etc,
but traversing the file system is pretty important for understanding
examples, when it comes to building images

---

# What is Docker?

> Docker is the world’s leading software container platform. Developers use Docker to eliminate “works on my machine” problems when collaborating on code with co-workers. Operators use Docker to run and manage apps side-by-side in isolated containers to get better compute density. Enterprises use Docker to build agile software delivery pipelines to ship new features faster, more securely and with confidence for both Linux, Windows Server, and Linux-on-mainframe apps. 

.footnote[https://www.docker.com/what-docker]

???

Straight off the website

Kind of sales-pitchy, but gets the point across

---

# What is a Container?

> Containers are a way to package software in a format that can run isolated on a shared operating system. Unlike VMs, containers do not bundle a full operating system - only libraries and settings required to make the software work are needed. This makes for efficient, lightweight, self-contained systems and guarantees that software will always run the same, regardless of where it’s deployed.

.footnote[https://www.docker.com/what-docker]

???

Straight off the website again

- Not VMs
- isolated (somewhat) - more info coming up next
- small, fast, effecient
- **repeatability**
- Lend themselves very well to automated orchestration

---

# Containers != VMs

To blatantly steal a great metaphor (watch the talk linked below):

VMs package an **entire system**
- Kernel
- Drivers
- Libraries
- Software
- etc

VMs are like houses.
- Houses are freestanding buildings 
- Houses have their own plumbing, electrical, etc

.footnote[[Mike Coleman, "Docker?!? But I'm a SYSADMIN!" - Dockercon 2017](https://www.youtube.com/watch?v=M7ZBF-JJWVU)]

---

# Containers != VMs, cont'd

Containers package a **service** 
- Libraries
- Application

Containers are like apartments
- There are many apartments in a single building
- Apartments share access to many key components, eg: plumbling, electrical

---

# Containers != VMs, cont'd

With this in mind, VMs and containers are typically used in different situations,
with different expectations.

- VMs are commonly used to package complex, potentially stateful, applications.
- VMs are more "permanent" after being created.
- VMs more frequently run multiple services per VM
<hr />
- Containers are commonly used to package simple, usually stateless, applications.
- Containers are ephemeral, appearing and disappearing as required
- Containers often run a single service (if not single process) per container

---

# Containers ∪ VMs

Containers and Virtual Machines are different.

Containers and VMs are both appropriate in different situations.

You should probably know how to use both containers and virtual machines.

You should also know when to use containers and/or virtual machines.

(hint: the talk below helps know when to use what, watch it)

.footnote[[Mike Coleman, "Docker?!? But I'm a SYSADMIN!" - Dockercon 2017](https://www.youtube.com/watch?v=M7ZBF-JJWVU)]

???

The container-folk aren't coming for your VMs with torches and pitchforks
But this isn't a talk about VMs, so lets get on with it

---

# Demo Preparation

We're about to do some demos.

- Have docker installed? 
    - Cool - you can do them locally if you want

- Don't have docker installed? (or just don't want to do them locally?)
    - Cool you can use [play-with-docker.com](http://play-with-docker.com)

If you're using play-with-docker, go ahead and click "+ Add New Instance" on the left.

Can't see "+ Add New Instance"? The website gets a little weird with wrapping sometimes, try and make it fullscreen.

???

Give people a minute to get setup

Encourage people to help those next to them having trouble

---

# Running a Container

So, now that we know (more or less) what containers are, and we've got ourselves 
setup with play-with-docker (or our local docker environments)...

Let's try running one!

This will run an Ubuntu container, and drop you to a bash prompt
```bash
$ docker run -t -i ubuntu bash
```

If bash isn't your thing...
```bash
$ docker run -ti python
```

???

- Running an ubuntu||python image
- Does that say root in the prompt?
    - It does.
- Can potentially do something drastic, like delete bin
    - Demonstrate that **this isn't the host**
- Can demonstrate re-running, to show how fast it is when
you don't have to download the image. Serious difference from VMs.

---

# Running a Container, cont'd

 Command Breakdown

- .remark-inline-code[docker]: The docker CLI utility
- .remark-inline-code[run]: The subparser for running containers
- .remark-inline-code[-t]: "tty", allocate a pseudo-tty
- .remark-inline-code[-i]: "interactive", capture stdin
- .remark-inline-code[ubuntu||python]: the image to use
- .remark-inline-code[bash]: The command to call within the container
    - Some images have implicit "entrypoints", like Python
    does with the REPL

???

- **Interactive containers are not necessarily the norm**
    - we're going to run a service next

---

# Intermezzo
## What did I just download?!

You just downloaded an Ubuntu (or python) docker image!

- Docker images are "layers" which make up some container
    - more on layers later
- They can be pushed (or pulled) from the [DockerHub](https://hub.docker.com)
- The DockerHub is a little like a package manager
- Some packages, like Ubuntu or Python are "official" packages
    - Maintained by organization or Docker
- **Always** know what images you're running, especially if from an "unofficial"
source
    - Docker supports various security metrics for this
        - They are outside of the scope of this talk
    - Don't run programs you download off the internet
        - _sarcasm_ (kind of)

???

Don't get side tracked on layers here - they get gone over in "Building
an Image" later.

The security note here is a valid one, but definitely outside of the
scope of this talk, be sure to re-iterate to examine images occasionally
(especially unofficial images, and especially if they are going to be in
contact with sensitive data)

---

# Running a Container, cont'd

Lets try running something more "service-y"

```bash
$ docker run -t alpine ping www.google.com
```

Just like the output of ping from our host, except the container is running it!

???

Note the -t but no -i, we don't need to supply any input here.

---

# Intermezzo
## What's alpine?

Alpine is a tiny linux distribution.

We use it here because it's small, and so quick to download and run.

Size is often a concern with Docker containers, if you are going to distribute
them widely or duplicate them tens, hundreds, or thousands of times across hosts.

For this reason you often see Docker images built off of an alpine base, it has
some nice tools like a package manager, most of the gnu utilities, etc but is 
still very small compared to your typical distros (Ubuntu/Redhat/Debian/etc). 
This makes it ideal for mantaining core functionality and convenience in 
Docker images, while not bogging down images.

In addition to size, it is often advisable to be running as little as possible (besides
your application of course) inside of a container. A minimal distro, with fewer bells and
whistles to begin with, is often easier to achieve this with.

---

# Running a Container, cont'd

Running a service in a container isn't tremendously useful if it locks up
our entire host, however.

Why don't we try running the same "service" **d**etached from our terminal.

```bash
$ docker run -d alpine ping www.google.com
```

To have a peak inside...

```bash
$ docker logs $identifier
```

Or, in the style of .remark-inline-code[tail -f somelog.log]

```bash
$ docker logs -f $identifier
```

---

# Running a Container, cont'd
## Check Up

We've run quite a few containers now, and in fact, we are still running one!

Let's take a look at the running containers.
```bash
$ docker ps
```

And a look at all the containers (even the stopped/exited ones)
```bash
$ docker ps -a
```

And, a handy little scriplet for dumping all the container identifiers
```bash
$ docker ps -aq
```

---
# Running a Container, cont'd
## Clean Up

Stop our ping container (we don't want to DDOS google)
```bash
$ docker stop $identifier
```

Remove the container
```bash
$ docker rm $identifier
```

And now let's remove all our stopped containers too, to clean up
```bash
$ docker rm $(docker ps -aq)
```

???

People might be be familar with the bashism in the final command,
it executes the command inside of $() and replaces that portion of the
command with the output

---
# Running a Container, cont'd

While pinging google is great for checking network connectivity, maybe
we should demonstrate something slightly more useful.

In this example, we will run a service (nginx with the default configuration) in a container, and interact with it from outside of the container via port mapping.

Let's fire up our container **d**etached, and use the .remark-inline-code[-p] flag to publish port 80 in the container on port 80 of the host. 

We can also use the .remark-inline-code[--name] flag to give our container an easy to remember name.
```bash
$ docker run -d -p 80:80 --name webserver nginx
```

After we do this, interacting with port 80 on our host will forward that traffic to port 80 inside of the container
```bash
$ curl localhost:80
```

---

# Running a Container, cont'd

And cleanup is quick and easy
```bash
$ docker stop webserver
```

```bash
$ docker rm webserver
```

Leaving nothing after we stop the container
```bash
$ curl localhost:80
```

---

# Containers Alongside Your Code

The same principal as the previous nginx example can be used to leverage docker containers
alongside your code in order to provide services during development, without the hassle 
of setting up, maintaining, resetting, etc test servers for services like databases.

For example, imagine if I were in the early stages of writing a [Clipboard-as-a-Service web clipboard syncronization tool...](https://github.com/bnbalsamo/webclip)

---

# Containers Alongside Your Code, cont'd

With this written, would you rather...

1. Mock a redis object which implements the functionality the code relies on to test
2. Use a real redis server to test

in order to test out your proof of concept?

Option #1
- Disconnects your code from the underlying redis implementation
    - Are you positive you mocked that object right?
    - What if the dependency interface changes?
    - etc
- Can be more complicated than the original program!
    - As in this case

Option #2
- Requires setting up a whole redis server!

---

# Containers Alongside Your Code, cont'd

## Docker to the rescue!

```bash
$ docker run -d -p 6379:6379 redis
$ py.test
```

---

# Containers Alongside Your Code, cont'd

This process can be applied to many "dockerized" network services.

[Explore the Dockerhub](https://hub.docker.com/explore/) for ideas!

or

Dockerize your own services!

---

# Building a Container

Now that we've worked on how to run containers, and how to use running
containers for practical benefit while developing, let's address building
our own containers!

The first step to building a container is understanding, at a slightly more
granular level, what a container _is_.

To do this, I'll employ a good ole OO programming metaphor:

All containers are built from images, in the way that all objects are built
from classes.

The same way a single class can be used to create many objects, a single image
can be used to create many containers.

---

# Building a Container, cont'd

In much the same a class utilizes a constructor, Docker images use Dockerfiles.

Dockerfiles define a series of actions which initialize the beginning "state" of
every container built off the image the Dockerfile defines.

Each "action" defined in a Dockerfile produces a layer, these layers are then stacked,
one on top of the other, to produce the resulting image.

In this sense, images can be considered "base classes" which are optionally extensible.

---

# Building a Container, cont'd

TODO: Explain Dockerfiles

---

# Building a Container, cont'd

TODO: Basic Dockerfile

---

# Your Code in a Container

TODO: Build basic Dockerfile
TODO: Run basic Dockerfile

---

# Additional Reading/Watching

- .remark-inline-code[docker --help]
- .remark-inline-code[docker run --help]
    - Really all the help documentation is great
- [Dockerfile Reference](https://docs.docker.com/engine/reference/builder/)
- Video: [Jerome Petazzoni, AJ Bowen," Deploy and Scale Containers with Docker Native, Open Source Orchestration" - PyCon 2017](https://www.youtube.com/watch?v=EuzoEaE6Cqs)
- Video: [Mike Coleman, "Docker?!? But I'm a SYSADMIN!" - Dockercon 2017](https://www.youtube.com/watch?v=M7ZBF-JJWVU)

---

class: middle

.center[**Thank you**]

.center[Questions?]

.center[Brian Balsamo]
.center[brian@brianbalsamo.com]
